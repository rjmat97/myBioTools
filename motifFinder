import pandas as pd
import numpy as np
import re, json
import sys
if sys.version_info[0] < 3: from StringIO import StringIO
else: from io import StringIO
from Bio import SeqIO
import json
from pathlib import Path
import argparse
from signal import signal, SIGPIPE, SIG_DFL

revcomp = str.maketrans('GATCWSN','CTAGWSN')
nucleotides = { 'A': "A", 'C': "C", 'G': "G", 'T': "T", 'R': "[AG]", 'Y': "[CT]", 'S': "[GC]", 'W': "[AT]", 'K': "[GT]", 'M': "[AC]", 'B': "[ACT]", 'D': "[AGT]", 'H': "[ACT]", 'V': "[ACG]", 'N': "[ATCG]", }

def openFastaFile(fi):
    rfOb = SeqIO.parse(open(fi),'fasta')
    fileArr, key={}, ''
    for record in rfOb.records:
        fileArr[record.id] = str(record.seq)
    return fileArr

def loadOneline(file):
    with open(file) as f: r = json.load(f)
    return r


def findMotif(chr, fasta, motif, offset=0):
    revOff = len(motif)-offset-1
    motifRGX = ''.join([nucleotides[i] for i in motif.upper()])
    p1 = [i.start()+offset for i in re.finditer(motifRGX, fasta)]
    p2 = []

    # if len(set(motif).difference('GATCWSN'))==0 and motif.translate(revcomp)[::-1]==motif:
    #     p2 = [i.start()+revOff for i in re.finditer(motifRGX, fasta)]
    # else: 
    revMot = motif.upper()[::-1]
    rfasta = fasta.translate(revcomp)
    motifRGXrev = ''.join([nucleotides[i] for i in revMot])
    # p2 = [i.end()-offset-1 for i in re.finditer(motifRGXrev, rfasta)]
    p2 = [i.end()-offset for i in re.finditer(motifRGXrev, rfasta)]
    
    pos  = [f'{chr}\t{l}\t{l+1}\t{motif}\t.\t{"+"}' for l in p1]
    pos += [f'{chr}\t{l-1}\t{l}\t{motif}\t.\t{"-"}' for l in p2]
    return pos 

def getMotif(file):
    t = pd.read_csv(file, sep="\t", names=['chr', 'p1', 'p2', 'motif', 's', 'strand'])
    return t

def makeBed(fastaOb, motif, offset=0):
    outData = [] 
    for chr in fastaOb.keys(): outData += findMotif(chr, fastaOb[chr], motif, offset)
    outData = '\n'.join(outData)
    return getMotif(StringIO(outData)).sort_values(['chr', 'p1','strand']).reset_index(drop=True)

def importBedFile(file):
    return pd.read_csv(file, sep="\t", names=['chr', 'p1', 'p2', 'motif', 's', 'strand'])

def check(srch, comp):
    srchregex = ''.join([nucleotides[i] for i in srch])
    return bool(re.search(f'^{srchregex}$', comp)), comp

def saveBed(bedOb, savFileName):
    with open(savFileName, 'w+') as f: f.write(bedOb)

def get_args():
    parser = argparse.ArgumentParser(description=(f"""This script generates bed files with the start and end
    locations centred around the modified locations

    accepted notations:
    --------------------------------------
    {'a'.rjust(7)} - 6mA
    {'m'.rjust(7)} - 5mC
    {'ATGC'.rjust(7)} - cononical bases
    {'RYSWKM'.rjust(7)} - wildcard bases 
    {'BDHV'.rjust(7)} - wildcard bases 
    {'N'.rjust(7)} - any of the 4 canonical bases
    """
),formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-r', '--ref', type=str, help='refernece fasta file', required=True)
    parser.add_argument('-m', '--motif', type=str, help='Motif location', required=True)
    parser.add_argument('-c', '--chr', type=str, help='chromosome name to keep', default="")
    parser.add_argument('-O', '--offset', type=int, help='index of notif nucleotide to pick in bed file', default=0)
    parser.add_argument('-o', '--output', type=str, help='Output File', default="")
    parser.add_argument('-H', '--header', action='store_true', help='print headers')
    
    return parser.parse_args()

if __name__ == "__main__":
    args = get_args()
    # bedfile, reference, motif, modKit, outFile, cache, min_depth, nlabel = args.bed, args.ref, args.motif, args.mod_kit, , args.cache_all, args.min_depth, args.name

    ref = args.ref
    motif = args.motif

    regOb = re.search('[am]', 'GATC')
    if regOb==None:
        offset = args.offset
        motif = args.motif.upper()
    else:
        methNucleotide = regOb.group(0)
        offset = regOb.span(0)[0]

    chrom = args.chr
    outbed = args.output

    data = openFastaFile(ref)
    bed = makeBed(data, motif, offset=offset)
    if len(chrom)!=0: bed = bed.query('chr==@chrom').copy().reset_index(drop=True)

    if args.output!="": 
        path = Path(outbed)
        if Path(str(path.parent)).exists()==False: Path.mkdir(Path(directory))
        bed.reset_index(drop=True).to_csv(f'{directory}/{abbr}_{motif}.bed', sep="\t", header=None, index=False)
    else:
        try:
            print(bed.to_csv(sep='\t', index=False, header=None))
        except BrokenPipeError:
            pass
